<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vmnet (vmnet.Vmnet)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">vmnet</a> &#x00BB; Vmnet</nav><h1>Module <code>Vmnet</code></h1><p>macOS userspace network bridging.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt><dd><p><code>t</code> contains the interface state for one vmnet interface.</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val </span>sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-mode"><a href="#type-mode" class="anchor"></a><code><span class="keyword">type </span>mode</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-mode.Host_mode" class="anchored"><td class="def constructor"><a href="#type-mode.Host_mode" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Host_mode</span></code></td></tr><tr id="type-mode.Shared_mode" class="anchored"><td class="def constructor"><a href="#type-mode.Shared_mode" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Shared_mode</span></code></td></tr></table></dt><dd><p><code>mode</code> controls the level of sharing exposed to the vmnet interface.</p><ul><li><a href="index.html#type-mode.Host_mode"><code>Host_mode</code></a> lets the guest network interface communicate with other guest network interfaces in the host mode and to the native host.</li><li><a href="index.html#type-mode.Shared_mode"><code>Shared_mode</code></a> lets the guest network interface reach the Internet using a network address translator.</li></ul><p>Note that in MacOS X Yosemite, <a href="index.html#type-mode.Host_mode"><code>Host_mode</code></a> also provides a NAT to the guest, but with the subnet and DNS options not set (so it has no way to communicate externally but can still retrieve host-local network configuration via DHCP).</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-mode_of_sexp"><a href="#val-mode_of_sexp" class="anchor"></a><code><span class="keyword">val </span>mode_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-mode">mode</a></code></dt><dt class="spec value" id="val-sexp_of_mode"><a href="#val-sexp_of_mode" class="anchor"></a><code><span class="keyword">val </span>sexp_of_mode : <a href="index.html#type-mode">mode</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type </span>error</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-error.Failure" class="anchored"><td class="def constructor"><a href="#type-error.Failure" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Failure</span></code></td></tr><tr id="type-error.Mem_failure" class="anchored"><td class="def constructor"><a href="#type-error.Mem_failure" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Mem_failure</span></code></td></tr><tr id="type-error.Invalid_argument" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_argument" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Invalid_argument</span></code></td></tr><tr id="type-error.Setup_incomplete" class="anchored"><td class="def constructor"><a href="#type-error.Setup_incomplete" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Setup_incomplete</span></code></td></tr><tr id="type-error.Invalid_access" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_access" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Invalid_access</span></code></td></tr><tr id="type-error.Packet_too_big" class="anchored"><td class="def constructor"><a href="#type-error.Packet_too_big" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Packet_too_big</span></code></td></tr><tr id="type-error.Buffer_exhausted" class="anchored"><td class="def constructor"><a href="#type-error.Buffer_exhausted" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Buffer_exhausted</span></code></td></tr><tr id="type-error.Too_many_packets" class="anchored"><td class="def constructor"><a href="#type-error.Too_many_packets" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Too_many_packets</span></code></td></tr><tr id="type-error.Unknown" class="anchored"><td class="def constructor"><a href="#type-error.Unknown" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unknown</span><span class="keyword"> of </span>int</code></td></tr></table></dt><dd><p><code>error</code> represents hard failures from the underlying vmnet functions.</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-error_of_sexp"><a href="#val-error_of_sexp" class="anchor"></a><code><span class="keyword">val </span>error_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-error">error</a></code></dt><dt class="spec value" id="val-sexp_of_error"><a href="#val-sexp_of_error" class="anchor"></a><code><span class="keyword">val </span>sexp_of_error : <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Error</span><span class="keyword"> of </span><a href="index.html#type-error">error</a></code></dt><dd><p><code>Error</code> can be raised by vmnet functions when hard errors are encountered.</p></dd></dl><div><div class="spec include"><div class="doc"></div></div></div><dl><dt class="spec exception" id="exception-Permission_denied"><a href="#exception-Permission_denied" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Permission_denied</span></code></dt><dd><p><code>Permission_denied</code> can be raised if the process needs root privileges (or the vmnet capability)</p></dd></dl><dl><dt class="spec exception" id="exception-No_packets_waiting"><a href="#exception-No_packets_waiting" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">No_packets_waiting</span></code></dt><dd><p><code>No_packets_waiting</code> is raised when <a href="index.html#val-read"><code>read</code></a> is called on an interface that has no packets queued. <a href="index.html#val-wait_for_event"><code>wait_for_event</code></a> can be used to block the client until packets do arrive.</p></dd></dl><div><div class="spec include"><div class="doc"></div></div></div><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : ?&#8288;mode:<a href="index.html#type-mode">mode</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init ?mode</code> will initialise a fresh vmnet interface, defaulting to <a href="index.html#type-mode.Shared_mode"><code>Shared_mode</code></a> for the output. Raises <a href="index.html#exception-Error"><code>Error</code></a> if something goes wrong.</p></dd></dl><dl><dt class="spec value" id="val-mac"><a href="#val-mac" class="anchor"></a><code><span class="keyword">val </span>mac : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Macaddr.t</code></dt><dd><p><code>mac t</code> will return the MAC address bound to the guest network interface.</p></dd></dl><dl><dt class="spec value" id="val-mtu"><a href="#val-mtu" class="anchor"></a><code><span class="keyword">val </span>mtu : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>mtu t</code> will return the Maximum Transmission Unit (MTU) bound to the guest network interface.</p></dd></dl><dl><dt class="spec value" id="val-max_packet_size"><a href="#val-max_packet_size" class="anchor"></a><code><span class="keyword">val </span>max_packet_size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>max_packet_size t</code> will return the maximum allowed packet buffer that can be passed to <a href="index.html#val-write"><code>write</code></a>. Exceeding this will raise <a href="index.html#type-error.Packet_too_big"><code>Packet_too_big</code></a> from <a href="index.html#val-write"><code>write</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_event_handler"><a href="#val-set_event_handler" class="anchor"></a><code><span class="keyword">val </span>set_event_handler : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_event_handler t</code> will initalise the internal thread state in the library that listen for event notifications from the library. The <a href="index.html#val-wait_for_event"><code>wait_for_event</code></a> function should not be called until this <a href="index.html#val-set_event_handler"><code>set_event_handler</code></a> been called once.</p></dd></dl><dl><dt class="spec value" id="val-wait_for_event"><a href="#val-wait_for_event" class="anchor"></a><code><span class="keyword">val </span>wait_for_event : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>wait_for_event t</code> will block the current OCaml thread until an event notification has been received on the <code>t</code> vmnet interface.</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val </span>read : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> Cstruct.t</code></dt><dd><p><code>read t buf</code> will read a network packet into the <code>buf</code> <span class="xref-unresolved" title="unresolved reference to &quot;Cstruct.t&quot;"><code>Cstruct</code>.t</span> and return a fresh subview that represents the packet with the correct length and offset. It will raise <a href="index.html#exception-No_packets_waiting"><code>No_packets_waiting</code></a> if there is nothing to read.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val </span>write : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write t buf</code> will transmit a network packet contained in <code>buf</code>. This will normally not block, but the vmnet interface isnt clear on whether this might happen.</p></dd></dl></div></body></html>